#include "graphics.hpp"

#include <cstring>

#include "core/process.hpp"
#include "core/scheduler.hpp"
#include "io.hpp"
#include "keyboard.hpp"
#include "mouse.hpp"
#include "terminal.hpp"
#include "vga.hpp"

constexpr uint8_t STATUS_OUTPUT_BUFFER_FULL = 0x01;
constexpr uint8_t STATUS_MOUSE_DATA = 0x20;

constexpr uint16_t VGA_AC_INDEX = 0x3C0;
constexpr uint16_t VGA_AC_WRITE = 0x3C0;
constexpr uint16_t VGA_AC_READ = 0x3C1;
constexpr uint16_t VGA_MISC_WRITE = 0x3C2;
constexpr uint16_t VGA_SEQ_INDEX = 0x3C4;
constexpr uint16_t VGA_SEQ_DATA = 0x3C5;
constexpr uint16_t VGA_DAC_INDEX_READ = 0x3C7;
constexpr uint16_t VGA_DAC_INDEX_WRITE = 0x3C8;
constexpr uint16_t VGA_DAC_DATA = 0x3C9;
constexpr uint16_t VGA_MISC_READ = 0x3CC;
constexpr uint16_t VGA_GC_INDEX = 0x3CE;
constexpr uint16_t VGA_GC_DATA = 0x3CF;
constexpr uint16_t VGA_CRTC_INDEX = 0x3D4;
constexpr uint16_t VGA_CRTC_DATA = 0x3D5;
constexpr uint16_t VGA_INSTAT_READ = 0x3DA;

constexpr uint32_t VGA_FRAMEBUFFER = 0xA0000;
uint8_t* vga_framebuffer = reinterpret_cast<uint8_t*>(VGA_FRAMEBUFFER);

constexpr uint8_t cursor_bitmap[16][16] = {{1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                           {1, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                           {1, 2, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                           {1, 2, 2, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                           {1, 2, 2, 2, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                           {1, 2, 2, 2, 2, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                           {1, 2, 2, 2, 2, 2, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0},
                                           {1, 2, 2, 2, 2, 2, 2, 2, 1, 0, 0, 0, 0, 0, 0, 0},
                                           {1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 0, 0, 0, 0, 0, 0},
                                           {1, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0},
                                           {1, 2, 2, 2, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                           {1, 2, 2, 1, 2, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
                                           {1, 2, 1, 0, 1, 2, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0},
                                           {1, 1, 0, 0, 0, 1, 2, 2, 1, 0, 0, 0, 0, 0, 0, 0},
                                           {0, 0, 0, 0, 0, 0, 1, 2, 2, 1, 0, 0, 0, 0, 0, 0},
                                           {0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0}};

uint8_t cursor_backup[16][16];
int32_t cursor_x = -1;
int32_t cursor_y = -1;

uint8_t g_320x200x256[] = {
    0x63, 0x03, 0x01, 0x0F, 0x00, 0x0E, 0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80, 0xBF, 0x1F, 0x00, 0x41,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9C, 0x0E, 0x8F, 0x28, 0x40, 0x96, 0xB9, 0xA3, 0xFF, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F, 0xFF, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x41, 0x00, 0x0F, 0x00, 0x00};

constexpr uint8_t font8x8[96][8] = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // Space (32)
    {0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00},  // !
    {0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00},  // "
    {0x6C, 0x6C, 0xFE, 0x6C, 0xFE, 0x6C, 0x6C, 0x00},  // #
    {0x18, 0x7E, 0xC0, 0x7C, 0x06, 0xFC, 0x18, 0x00},  // $
    {0x00, 0xC6, 0xCC, 0x18, 0x30, 0x66, 0xC6, 0x00},  // %
    {0x38, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0x76, 0x00},  // &
    {0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},  // '
    {0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00},  // (
    {0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00},  // )
    {0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00},  // *
    {0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00},  // +
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30},  // ,
    {0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00},  // -
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00},  // .
    {0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00},  // /
    {0x7C, 0xC6, 0xCE, 0xD6, 0xE6, 0xC6, 0x7C, 0x00},  // 0
    {0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00},  // 1
    {0x7C, 0xC6, 0x06, 0x1C, 0x30, 0x66, 0xFE, 0x00},  // 2
    {0x7C, 0xC6, 0x06, 0x3C, 0x06, 0xC6, 0x7C, 0x00},  // 3
    {0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x1E, 0x00},  // 4
    {0xFE, 0xC0, 0xC0, 0xFC, 0x06, 0xC6, 0x7C, 0x00},  // 5
    {0x38, 0x60, 0xC0, 0xFC, 0xC6, 0xC6, 0x7C, 0x00},  // 6
    {0xFE, 0xC6, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00},  // 7
    {0x7C, 0xC6, 0xC6, 0x7C, 0xC6, 0xC6, 0x7C, 0x00},  // 8
    {0x7C, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0x78, 0x00},  // 9
    {0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00},  // :
    {0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x30},  // ;
    {0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x00},  // <
    {0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00},  // =
    {0x30, 0x18, 0x0C, 0x06, 0x0C, 0x18, 0x30, 0x00},  // >
    {0x7C, 0xC6, 0x0C, 0x18, 0x18, 0x00, 0x18, 0x00},  // ?
    {0x7C, 0xC6, 0xDE, 0xDE, 0xDE, 0xC0, 0x7C, 0x00},  // @
    {0x38, 0x6C, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0x00},  // A
    {0xFC, 0x66, 0x66, 0x7C, 0x66, 0x66, 0xFC, 0x00},  // B
    {0x3C, 0x66, 0xC0, 0xC0, 0xC0, 0x66, 0x3C, 0x00},  // C
    {0xF8, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00},  // D
    {0xFE, 0x62, 0x68, 0x78, 0x68, 0x62, 0xFE, 0x00},  // E
    {0xFE, 0x62, 0x68, 0x78, 0x68, 0x60, 0xF0, 0x00},  // F
    {0x3C, 0x66, 0xC0, 0xC0, 0xCE, 0x66, 0x3E, 0x00},  // G
    {0xC6, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0x00},  // H
    {0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00},  // I
    {0x1E, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78, 0x00},  // J
    {0xE6, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0xE6, 0x00},  // K
    {0xF0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00},  // L
    {0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6, 0xC6, 0x00},  // M
    {0xC6, 0xE6, 0xF6, 0xDE, 0xCE, 0xC6, 0xC6, 0x00},  // N
    {0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00},  // O
    {0xFC, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00},  // P
    {0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xCE, 0x7C, 0x0E},  // Q
    {0xFC, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0xE6, 0x00},  // R
    {0x7C, 0xC6, 0xE0, 0x7C, 0x06, 0xC6, 0x7C, 0x00},  // S
    {0x7E, 0x5A, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00},  // T
    {0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00},  // U
    {0xC6, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x10, 0x00},  // V
    {0xC6, 0xC6, 0xC6, 0xD6, 0xFE, 0xEE, 0xC6, 0x00},  // W
    {0xC6, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0xC6, 0x00},  // X
    {0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x3C, 0x00},  // Y
    {0xFE, 0xC6, 0x8C, 0x18, 0x32, 0x66, 0xFE, 0x00},  // Z
    {0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00},  // [
    {0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00},  // backslash
    {0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00},  // ]
    {0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00},  // ^
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF},  // _
    {0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00},  // `
    {0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00},  // a
    {0xE0, 0x60, 0x7C, 0x66, 0x66, 0x66, 0xDC, 0x00},  // b
    {0x00, 0x00, 0x7C, 0xC6, 0xC0, 0xC6, 0x7C, 0x00},  // c
    {0x1C, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0x76, 0x00},  // d
    {0x00, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0x7C, 0x00},  // e
    {0x3C, 0x66, 0x60, 0xF8, 0x60, 0x60, 0xF0, 0x00},  // f
    {0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8},  // g
    {0xE0, 0x60, 0x6C, 0x76, 0x66, 0x66, 0xE6, 0x00},  // h
    {0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00},  // i
    {0x06, 0x00, 0x06, 0x06, 0x06, 0x66, 0x66, 0x3C},  // j
    {0xE0, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0xE6, 0x00},  // k
    {0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00},  // l
    {0x00, 0x00, 0xEC, 0xFE, 0xD6, 0xD6, 0xC6, 0x00},  // m
    {0x00, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x00},  // n
    {0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0x00},  // o
    {0x00, 0x00, 0xDC, 0x66, 0x66, 0x7C, 0x60, 0xF0},  // p
    {0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0x1E},  // q
    {0x00, 0x00, 0xDC, 0x76, 0x66, 0x60, 0xF0, 0x00},  // r
    {0x00, 0x00, 0x7C, 0xC0, 0x7C, 0x06, 0xFC, 0x00},  // s
    {0x30, 0x30, 0xFC, 0x30, 0x30, 0x36, 0x1C, 0x00},  // t
    {0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00},  // u
    {0x00, 0x00, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00},  // v
    {0x00, 0x00, 0xC6, 0xD6, 0xD6, 0xFE, 0x6C, 0x00},  // w
    {0x00, 0x00, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0x00},  // x
    {0x00, 0x00, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0xFC},  // y
    {0x00, 0x00, 0x7E, 0x4C, 0x18, 0x32, 0x7E, 0x00},  // z
    {0x0E, 0x18, 0x18, 0x70, 0x18, 0x18, 0x0E, 0x00},  // {
    {0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00},  // |
    {0x70, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x70, 0x00},  // }
    {0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},  // ~
    {0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0x00},  // DEL
};

bool in_graphics_mode = false;

void write_registers(uint8_t* registers) {
    outb(VGA_MISC_WRITE, *registers++);

    for (uint8_t i = 0; i < 5; i++) {
        outb(VGA_SEQ_INDEX, i);
        outb(VGA_SEQ_DATA, *registers++);
    }

    outb(VGA_CRTC_INDEX, 0x03);
    outb(VGA_CRTC_DATA, inb(VGA_CRTC_DATA) | 0x80);
    outb(VGA_CRTC_INDEX, 0x11);
    outb(VGA_CRTC_DATA, inb(VGA_CRTC_DATA) & ~0x80);

    for (uint8_t i = 0; i < 25; i++) {
        outb(VGA_CRTC_INDEX, i);
        outb(VGA_CRTC_DATA, *registers++);
    }

    for (uint8_t i = 0; i < 9; i++) {
        outb(VGA_GC_INDEX, i);
        outb(VGA_GC_DATA, *registers++);
    }

    for (uint8_t i = 0; i < 21; i++) {
        inb(VGA_INSTAT_READ);
        outb(VGA_AC_INDEX, i);
        outb(VGA_AC_WRITE, *registers++);
    }

    inb(VGA_INSTAT_READ);
    outb(VGA_AC_INDEX, 0x20);
}

void set_mode13h() {
    __asm__ volatile("cli");

    outb(VGA_SEQ_INDEX, 0x01);
    outb(VGA_SEQ_DATA, inb(VGA_SEQ_DATA) | 0x20);

    write_registers(g_320x200x256);

    outb(VGA_DAC_INDEX_WRITE, 0);
    outb(VGA_DAC_DATA, 0);
    outb(VGA_DAC_DATA, 0);
    outb(VGA_DAC_DATA, 0);

    outb(VGA_DAC_INDEX_WRITE, 1);
    outb(VGA_DAC_DATA, 0);
    outb(VGA_DAC_DATA, 0);
    outb(VGA_DAC_DATA, 0);

    outb(VGA_DAC_INDEX_WRITE, 2);
    outb(VGA_DAC_DATA, 63);
    outb(VGA_DAC_DATA, 63);
    outb(VGA_DAC_DATA, 63);

    for (int i = 3; i < 16; i++) {
        outb(VGA_DAC_INDEX_WRITE, i);

        switch (i) {
            case 4:
                outb(VGA_DAC_DATA, 63);
                outb(VGA_DAC_DATA, 0);
                outb(VGA_DAC_DATA, 0);
                break;
            case 2:
                outb(VGA_DAC_DATA, 0);
                outb(VGA_DAC_DATA, 63);
                outb(VGA_DAC_DATA, 0);
                break;
            case 9:
                outb(VGA_DAC_DATA, 0);
                outb(VGA_DAC_DATA, 0);
                outb(VGA_DAC_DATA, 63);
                break;
            case 15:
                outb(VGA_DAC_DATA, 63);
                outb(VGA_DAC_DATA, 63);
                outb(VGA_DAC_DATA, 63);
                break;
            default:
                outb(VGA_DAC_DATA, 32);
                outb(VGA_DAC_DATA, 32);
                outb(VGA_DAC_DATA, 32);
                break;
        }
    }

    outb(VGA_SEQ_INDEX, 0x01);
    outb(VGA_SEQ_DATA, inb(VGA_SEQ_DATA) & ~0x20);

    __asm__ volatile("sti");
}

void graphics_initialize() {
    // no-op
}

void set_pixel(uint16_t x, uint16_t y, uint8_t color) {
    if (x < GRAPHICS_WIDTH && y < GRAPHICS_HEIGHT) vga_framebuffer[y * GRAPHICS_WIDTH + x] = color;
}

void clear_screen(uint8_t color) {
    memset(vga_framebuffer, color, GRAPHICS_WIDTH * GRAPHICS_HEIGHT);
}

void save_cursor_background(int32_t x, int32_t y) {
    for (int i = 0; i < 16; i++) {
        for (int j = 0; j < 16; j++) {
            if (x + j >= 0 && y + i >= 0 && x + j < GRAPHICS_WIDTH && y + i < GRAPHICS_HEIGHT)
                cursor_backup[i][j] = vga_framebuffer[(y + i) * GRAPHICS_WIDTH + (x + j)];
        }
    }
}

void restore_cursor_background(int32_t x, int32_t y) {
    for (int i = 0; i < 16; i++) {
        for (int j = 0; j < 16; j++) {
            if (x + j >= 0 && y + i >= 0 && x + j < GRAPHICS_WIDTH && y + i < GRAPHICS_HEIGHT)
                vga_framebuffer[(y + i) * GRAPHICS_WIDTH + (x + j)] = cursor_backup[i][j];
        }
    }
}

void render_mouse_cursor(int32_t x, int32_t y) {
    if (cursor_x != -1 && cursor_y != -1) restore_cursor_background(cursor_x, cursor_y);

    save_cursor_background(x, y);

    for (int i = 0; i < 16; i++) {
        for (int j = 0; j < 16; j++) {
            if (cursor_bitmap[i][j] != 0 && x + j >= 0 && y + i >= 0 && x + j < GRAPHICS_WIDTH &&
                y + i < GRAPHICS_HEIGHT)
                vga_framebuffer[(y + i) * GRAPHICS_WIDTH + (x + j)] = cursor_bitmap[i][j];
        }
    }

    cursor_x = x;
    cursor_y = y;
}

void draw_char(uint16_t x, uint16_t y, char c, uint8_t color) {
    if (static_cast<unsigned char>(c) < 32 || static_cast<unsigned char>(c) > 127) return;

    const uint8_t* char_data = font8x8[static_cast<unsigned char>(c) - 32];

    for (uint8_t row = 0; row < 8; row++) {
        for (uint8_t col = 0; col < 8; col++) {
            if (char_data[row] & (1 << (7 - col))) set_pixel(x + col, y + row, color);
        }
    }
}

void draw_string(uint16_t x, uint16_t y, const char* str, uint8_t color) {
    uint16_t current_x = x;

    while (*str) {
        draw_char(current_x, y, *str, color);
        current_x += 8;
        str++;

        if (current_x >= GRAPHICS_WIDTH - 8) break;
    }
}

void draw_status_bar() {
    for (uint16_t y = 0; y < STATUS_BAR_HEIGHT; y++) {
        for (uint16_t x = 0; x < GRAPHICS_WIDTH; x++) {
            set_pixel(x, y, STATUS_BAR_COLOR);
        }
    }
}

void update_status_bar_time(const RTCTime& time) {
    char time_str[9];

    time_str[0] = '0' + (time.hours / 10);
    time_str[1] = '0' + (time.hours % 10);
    time_str[2] = ':';
    time_str[3] = '0' + (time.minutes / 10);
    time_str[4] = '0' + (time.minutes % 10);
    time_str[5] = ':';
    time_str[6] = '0' + (time.seconds / 10);
    time_str[7] = '0' + (time.seconds % 10);
    time_str[8] = '\0';

    uint16_t time_x = GRAPHICS_WIDTH - (8 * 8) - 8;
    uint16_t time_y = 2;

    draw_string(time_x, time_y, time_str, STATUS_BAR_TEXT_COLOR);
}

void enter_graphics_mode() {
    set_mode13h();

    clear_screen(0);

    draw_status_bar();

    RTCTime time = get_rtc_time();
    update_status_bar_time(time);

    in_graphics_mode = true;

    cursor_x = -1;
    cursor_y = -1;

    auto& scheduler = kernel::Scheduler::instance();
    kernel::Process* current_process = kernel::ProcessManager::instance().get_current_process();
    if (current_process) scheduler.set_process_priority(current_process->pid, 10);

    MouseState lastMouseState = get_mouse_state();
    render_mouse_cursor(lastMouseState.x, lastMouseState.y);

    RTCTime lastTime = time;

    __asm__ volatile("sti");

    while (true) {
        if ((inb(KEYBOARD_STATUS_PORT) & STATUS_OUTPUT_BUFFER_FULL) != 0) {
            if (!(inb(KEYBOARD_STATUS_PORT) & STATUS_MOUSE_DATA)) {
                uint8_t scancode = inb(KEYBOARD_DATA_PORT);
                if (scancode == 1) break;
            } else
                inb(KEYBOARD_DATA_PORT);
        }

        MouseState currentMouse = get_mouse_state();

        if (currentMouse.x != lastMouseState.x || currentMouse.y != lastMouseState.y ||
            currentMouse.left_button != lastMouseState.left_button ||
            currentMouse.right_button != lastMouseState.right_button ||
            currentMouse.middle_button != lastMouseState.middle_button) {
            if (currentMouse.x != lastMouseState.x || currentMouse.y != lastMouseState.y) {
                if (cursor_x != -1 && cursor_y != -1) restore_cursor_background(cursor_x, cursor_y);

                save_cursor_background(currentMouse.x, currentMouse.y);

                for (int i = 0; i < 16; i++) {
                    for (int j = 0; j < 16; j++) {
                        if (cursor_bitmap[i][j] != 0 && currentMouse.x + j >= 0 &&
                            currentMouse.y + i >= 0 && currentMouse.x + j < GRAPHICS_WIDTH &&
                            currentMouse.y + i < GRAPHICS_HEIGHT) {
                            vga_framebuffer[(currentMouse.y + i) * GRAPHICS_WIDTH +
                                            (currentMouse.x + j)] = cursor_bitmap[i][j];
                        }
                    }
                }

                cursor_x = currentMouse.x;
                cursor_y = currentMouse.y;
            }

            lastMouseState = currentMouse;
        }

        RTCTime current_time = get_rtc_time();
        if (current_time.seconds != lastTime.seconds) {
            draw_status_bar();
            update_status_bar_time(current_time);
            lastTime = current_time;
        }

        for (volatile int i = 0; i < 500; i++)
            ;

        __asm__ volatile("sti; hlt");
    }

    __asm__ volatile("cli");
    terminal_initialize();
    __asm__ volatile("sti");

    in_graphics_mode = false;

    if (current_process) scheduler.set_process_priority(current_process->pid, 5);
}